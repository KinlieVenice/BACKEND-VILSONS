const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();
const { logActivity } = require("./activityService.js");

const processMonthlyAutoGenerateds = async () => {
  console.log("Processing monthly autoGenerateds...");

  try {
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth() + 1;
    const currentDay = now.getDate();

    // Get all employees with autoGenerated data
    const employees = await prisma.employee.findMany({
      where: {
        autoGenerated: { not: null },
      },
      include: {
        user: true,
      },
    });

    console.log(`Found ${employees.length} employees with autoGenerateds`);

    for (const employee of employees) {
      await processEmployeeAutoGenerateds(
        employee,
        currentYear,
        currentMonth,
        currentDay
      );
    }

    console.log("Monthly autoGenerateds processing completed");
  } catch (error) {
    console.error("Error processing monthly autoGenerateds:", error);
  }
};

const processEmployeeAutoGenerateds = async (
  employee,
  year,
  month,
  currentDay
) => {
  const autoGenerated = employee.autoGenerated;

  if (
    !autoGenerated ||
    !autoGenerated.branchId ||
    !Array.isArray(autoGenerated.payComponents)
  ) {
    return;
  }

  console.log("RAW autoGenerated:", autoGenerated, typeof autoGenerated);

  const branchId = autoGenerated.branchId;
  const lastDayOfMonth = getLastDayOfMonth(year, month);

  const componentsToPay = autoGenerated.payComponents.filter((component) => {
    // Support both "schedule" and "schedules" keys
    const componentSchedules = component.schedule || component.schedules;

    if (!Array.isArray(componentSchedules)) return false;

    return componentSchedules.some((scheduledDay) => {
      const dayNum = Number(scheduledDay);
      const adjustedDay = dayNum > lastDayOfMonth ? lastDayOfMonth : dayNum;
      return currentDay === adjustedDay;
    });
  });

  if (componentsToPay.length === 0) return;

  await createAutoEmployeePay(employee, branchId, componentsToPay);
};

const getLastDayOfMonth = (year, month) => {
  return new Date(year, month, 0).getDate();
};

const createAutoEmployeePay = async (employee, branchId, payComponents) => {
  try {
    console.log(
      `Creating auto employeePay for ${employee.user.fullName} with ${payComponents.length} components`
    );

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const existingAutoPayment = await prisma.employeePay.findFirst({
      where: {
        employeeId: employee.id,
        autoGenerated: true,
        createdAt: { gte: today, lt: tomorrow },
      },
    });

    if (existingAutoPayment) {
      console.log(
        `Auto payment already exists for ${employee.user.fullName} today. Skipping.`
      );
      return;
    }

    const result = await prisma.$transaction(async (tx) => {
      const employeePay = await tx.employeePay.create({
        data: {
          employeeId: employee.id,
          branchId,
          createdByUser: "superadmin",
          updatedByUser: "superadmin",
          autoGenerated: true,
        },
      });

      await tx.payComponent.createMany({
        data: payComponents.map((pc) => ({
          employeePayId: employeePay.id,
          componentId: pc.componentId,
          amount: Number(pc.amount) || 0,
          createdByUser: "superadmin",
          updatedByUser: "superadmin",
        })),
      });

      const employeePayWithComponents = await tx.employeePay.findUnique({
        where: { id: employeePay.id },
        include: {
          payComponents: { include: { component: true } },
          employee: {
            include: { user: { select: { username: true, fullName: true } } },
          },
          branch: { select: { id: true, branchName: true } },
        },
      });

      const totalComponentCost = payComponents.reduce(
        (sum, pc) => sum + Number(pc.amount),
        0
      );

      return { ...employeePayWithComponents, totalComponentCost };
    });

    await logActivity(
      "superadmin",
      `AutoGenerated created for ${employee.user.fullName}: ${payComponents.length} components totaling P${result.totalComponentCost}`
    );

    console.log(`Auto employeePay created: ID ${result.id}`);
  } catch (error) {
    console.error(
      `Failed to create auto employeePay for ${employee.user.fullName}:`,
      error
    );

    await logActivity(
      "superadmin",
      `AutoGenerated FAILED for ${employee.user.fullName}: ${error.message}`
    );
  }
};

const autoUpdatePendingJobOrders = async () => {
  console.log("Running auto-update for pending Job Orders...");

  try {
    const threeDaysAgo = new Date();
    threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);

    const updated = await prisma.jobOrder.updateMany({
      where: {
        status: "pending",
        contractorId: { not: null },
        createdAt: { lt: threeDaysAgo },
      },
      data: {
        status: "ongoing",
      },
    });

    console.log(`Auto-updated ${updated.count} job orders.`);
  } catch (err) {
    console.error("Auto-update Job Order Error:", err.message);
  }
};

const processMonthlyOverheads = async () => {
  console.log("Processing end-of-month automated overheads...");

  try {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth() + 1;
    const today = now.getDate();

    const lastDayOfMonth = getLastDayOfMonth(year, month);

    if (today !== lastDayOfMonth) {
      console.log("Not end of month. Skipping overhead automation.");
      return;
    }

    const automatedOverheads = await prisma.overhead.findMany({
      where: {
        automated: true,
      },
    });

    console.log(`Found ${automatedOverheads.length} automated overheads`);

    for (const overhead of automatedOverheads) {
      await createMonthEndOverhead(overhead, year, month);
    }

    console.log("End-of-month overhead processing completed");
  } catch (err) {
    console.error("Monthly overhead automation error:", err);
  }
};

const createMonthEndOverhead = async (sourceOverhead, year, month) => {
  // Prevent duplicates for same month
  const startOfMonth = new Date(year, month - 1, 1);
  const endOfMonth = new Date(year, month, 1);

  const existing = await prisma.overhead.findFirst({
    where: {
      branchId: sourceOverhead.branchId,
      description: sourceOverhead.description,
      automated: true,
      createdAt: {
        gte: startOfMonth,
        lt: endOfMonth,
      },
    },
  });

  if (existing) {
    console.log(
      `Overhead already exists for ${sourceOverhead.description} this month`
    );
    return;
  }

  const created = await prisma.overhead.create({
    data: {
      description: sourceOverhead.description,
      amount: sourceOverhead.amount,
      branchId: sourceOverhead.branchId,
      automated: true,
      createdByUser: "superadmin",
      updatedByUser: "superadmin",
    },
  });

  await logActivity(
    "superadmin",
    `Month-end overhead created: ${created.description} (${created.amount})`,
    created.branchId
  );

  console.log(`Month-end overhead created: ${created.id}`);
};


module.exports = {
  processMonthlyAutoGenerateds,
  autoUpdatePendingJobOrders,
  processMonthlyOverheads,
};
