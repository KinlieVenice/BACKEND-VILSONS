const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();
const { logActivity } = require("./activityService.js");


const processMonthlyAutoGenerateds = async () => {
  console.log("Processing monthly autoGenerateds...");

  try {
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth() + 1;
    const currentDay = now.getDate();

    // Get all employees with autoGenerated data
    const employees = await prisma.employee.findMany({
      where: {
        autoGenerated: {
          not: null,
        },
      },
      include: {
        user: true,
      },
    });

    console.log(`Found ${employees.length} employees with autoGenerateds`);

    // Process each employee
    for (const employee of employees) {
      await processEmployeeAutoGenerateds(
        employee,
        currentYear,
        currentMonth,
        currentDay
      );
    }

    console.log("Monthly autoGenerateds processing completed");
  } catch (error) {
    console.error("Error processing monthly autoGenerateds:", error);
  }
};

const processEmployeeAutoGenerateds = async (
  employee,
  year,
  month,
  currentDay
) => {
  const autoGenerated = employee.autoGenerated;

  if (
    !autoGenerated ||
    !autoGenerated.branchId ||
    !Array.isArray(autoGenerated.payComponents)
  ) {
    return;
  }
  console.log(
    "RAW autoGenerated:",
    employee.autoGenerated,
    typeof employee.autoGenerated
  );

  const branchId = autoGenerated.branchId;
  console.log(branchId)
  const lastDayOfMonth = getLastDayOfMonth(year, month);

  // Find components that should be paid today
  const componentsToPay = autoGenerated.payComponents.filter((component) => {
    if (!component.schedule || !Array.isArray(component.schedule)) return false;

    return component.schedule.some((scheduledDay) => {
      const adjustedDay =
        scheduledDay > lastDayOfMonth ? lastDayOfMonth : scheduledDay;
      return currentDay === adjustedDay;
    });
  });

  // If no components to pay today, exit
  if (componentsToPay.length === 0) {
    return;
  }

  // Create employeePay with only the components that are due today
  await createAutoEmployeePay(employee, branchId, componentsToPay);
};

const getLastDayOfMonth = (year, month) => {
  return new Date(year, month, 0).getDate();
};

const createAutoEmployeePay = async (employee, branchId, payComponents) => {
  try {
    console.log(
      `Creating auto employeePay for ${employee.user.fullName} with ${payComponents.length} components`
    );
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const existingAutoPayment = await prisma.employeePay.findFirst({
      where: {
        employeeId: employee.id,
        autoGenerated: true,
        createdAt: {
          gte: today,
          lt: tomorrow,
        },
      },
    });

    if (existingAutoPayment) {
      console.log(
        `Auto payment already exists for ${employee.user.fullName} today. Skipping.`
      );
      return;
    }

    // Use your existing createEmployeePay logic but automated
    const result = await prisma.$transaction(async (tx) => {
      // Create the employeePay record
      const employeePay = await tx.employeePay.create({
        data: {
          employeeId: employee.id,
          branchId,
          createdByUser: "superadmin", // System-generated
          updatedByUser: "superadmin",
          autoGenerated: true, // Flag to identify auto-generated payments
        },
      });

      // Create pay components
      await tx.payComponent.createMany({
        data: payComponents.map((pc) => ({
          employeePayId: employeePay.id,
          componentId: pc.componentId,
          amount: Number(pc.amount) || 0,
          createdByUser: "superadmin",
          updatedByUser: "superadmin",
        })),
      });

      // Get the full record with details
      const employeePayWithComponents = await tx.employeePay.findUnique({
        where: { id: employeePay.id },
        include: {
          payComponents: {
            include: { component: true },
          },
          employee: {
            include: {
              user: { select: { username: true, fullName: true } },
            },
          },
          branch: { select: { id: true, branchName: true } },
        },
      });

      const totalComponentCost = payComponents.reduce(
        (sum, pc) => sum + Number(pc.amount),
        0
      );

      return { ...employeePayWithComponents, totalComponentCost };
    });

    // Log the activity
    await logActivity(
      "superadmin",
      `AutoGenerated created for ${employee.user.fullName}: ${payComponents.length} components totaling $${result.totalComponentCost}`
    );

    console.log(`Auto employeePay created: ID ${result.id}`);
  } catch (error) {
    console.error(
      `Failed to create auto employeePay for ${employee.user.fullName}:`,
      error
    );

    // Log the failure
    await logActivity(
      "superadmin",
      `AutoGenerated FAILED for ${employee.user.fullName}: ${error.message}`
    );
  }
};

module.exports = {
  processMonthlyAutoGenerateds,
};