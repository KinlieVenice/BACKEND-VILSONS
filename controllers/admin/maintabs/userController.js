const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();
const bcrypt = require("bcrypt");
const fs = require("fs");
const path = require("path");
const { getDateRangeFilter } = require("../../../utils/filters/dateRangeFilter");
const getMainBaseRole = require("../../../utils/services/getMainBaseRole.js");
const checkCustomerRole = require("../../../utils/services/checkCustomerRole.js");
const parseArrayFields = require("../../../utils/services/parseArrayFields.js");
const deleteFile = require("../../../utils/services/imageDeleter.js");
const { requestApproval } = require("../../../utils/services/approvalService");
const { branchFilter } = require("../../../utils/filters/branchFilter");
const checkPendingApproval = require("../../../utils/services/checkPendingApproval")
const relationsChecker = require("../../../utils/services/relationsChecker");
const { logActivity } = require("../../../utils/services/activityService.js");
const updateScheduler = require("../../../middleware/updateSchedule.js")
const ROLES_LIST = require("../../../constants/ROLES_LIST");
const {
  getLastUpdatedAt,
} = require("../../../utils/services/lastUpdatedService");

const createUser = async (req, res) => {
  const parsedBody = parseArrayFields(req.body, [
    "roles",
    "branches",
    "autoGenerated",
  ]);
  const {
    name,
    username,
    phone,
    email,
    password,
    description,
    roles,
    branches,
    commission,
    autoGenerated
  } = parsedBody;

  const image = req.file ? req.file.filename : null;

  if (!name || !username || !phone || !roles) {
    return res.status(400).json({
      message: "Name, username, phone, and roles are required",
    });
  }

  try {
    const roleBaseNames = await Promise.all(
      roles.map((roleId) => getMainBaseRole(prisma, roleId))
    );

    const isContractor = roleBaseNames.includes(ROLES_LIST.CONTRACTOR);
    const isEmployee = roleBaseNames.includes(ROLES_LIST.EMPLOYEE);
    const hasCustomerRole = roleBaseNames.includes(ROLES_LIST.CUSTOMER);

    // ===== CONTRACTOR VALIDATION =====
    if (isContractor) {
      const commissionValue = Number(commission);

      if (commission === undefined)
        return res.status(400).json({ message: "Commission is required for contractor" });

      if (isNaN(commissionValue) || commissionValue < 0 || commissionValue > 1)
        return res.status(400).json({ message: "Commission must be between 0 and 1" });
    }

    // ===== EMPLOYEE AUTOGENERATED VALIDATION =====
    if (isEmployee && autoGenerated) {
      if (typeof autoGenerated !== "object")
        return res.status(400).json({ message: "autoGenerated must be an object" });

      if (!autoGenerated.branchId)
        return res.status(400).json({ message: "branchId is required in autoGenerated" });

      const branchExists = await prisma.branch.findFirst({
        where: { id: autoGenerated.branchId },
      });
      if (!branchExists)
        return res.status(400).json({ message: "branchId does not exist" });

      if (!Array.isArray(autoGenerated.payComponents))
        return res.status(400).json({ message: "payComponents must be an array" });

      for (const pc of autoGenerated.payComponents) {
        if (!pc.amount || isNaN(Number(pc.amount)) || Number(pc.amount) < 0)
          return res.status(400).json({ message: "Invalid pay component amount" });

        if (pc.schedule) {
          if (!Array.isArray(pc.schedule))
            return res.status(400).json({ message: "Schedule must be an array" });

          pc.schedule = [...new Set(pc.schedule.map(Number))].sort((a, b) => a - b);
        }
      }
    }

    if (!hasCustomerRole && (!branches || branches.length === 0)) {
      return res
        .status(400)
        .json({ message: "Branches are required for non-customer users" });
    }

    const existingUser = await prisma.user.findFirst({
      where: {
        status: "active",
        OR: [{ username }, ...(email ? [{ email }] : [])],
      },
    });

    if (existingUser)
      return res.status(400).json({ message: "Username or Email already exists" });

    const needsApproval = req.approval;

    const hashPwd = await bcrypt.hash(
      password || process.env.DEFAULT_PASSWORD,
      10
    );

    const userData = {
      fullName: name,
      username,
      phone: phone.toString(),
      ...(email && { email }),
      hashPwd,
      ...(description && { description }),
      createdByUser: req.username,
      updatedByUser: req.username,
      image,
      ...(needsApproval && {
        roles,
        branches,
        ...(isContractor && { commission: Number(commission) }),
        ...(isEmployee && autoGenerated && { autoGenerated }),
      }),
    };

    const result = await prisma.$transaction(async (tx) => {
      const user = needsApproval
        ? await requestApproval("user", null, "create", userData, req.username, branches[0])
        : await tx.user.create({ data: { ...userData, status: "active" } });

      if (!needsApproval) {
        // ===== NORMALIZE AUTOGENERATED PAY COMPONENTS =====
        let normalizedAutoGenerated = autoGenerated;

        if (isEmployee && autoGenerated?.payComponents?.length) {
          const normalizedComponents = await Promise.all(
            autoGenerated.payComponents.map(async (pc) => {
              if (pc.componentId) {
                const existing = await tx.component.findUnique({
                  where: { id: pc.componentId },
                });
                if (existing) return pc;
              }

              if (!pc.componentName)
                throw new Error("componentName is required for new pay components");

              let component = await tx.component.findFirst({
                where: { componentName: pc.componentName },
              });

              if (!component) {
                component = await tx.component.create({
                  data: { componentName: pc.componentName },
                });
              }

              return { ...pc, componentId: component.id };
            })
          );

          normalizedAutoGenerated = {
            ...autoGenerated,
            payComponents: normalizedComponents,
          };
        }

        // ===== ROLE TABLE CREATION =====
        const roleTableMap = {
          [ROLES_LIST.ADMIN]: () => tx.admin.create({ data: { userId: user.id } }),
          [ROLES_LIST.CUSTOMER]: () => tx.customer.create({ data: { userId: user.id } }),
          [ROLES_LIST.EMPLOYEE]: () =>
            tx.employee.create({
              data: {
                userId: user.id,
                ...(normalizedAutoGenerated && { autoGenerated: normalizedAutoGenerated }),
              },
            }),
          [ROLES_LIST.CONTRACTOR]: () =>
            tx.contractor.create({
              data: { userId: user.id, commission: Number(commission) },
            }),
        };

        const uniqueRoles = [...new Set(roleBaseNames)];
        await Promise.all(uniqueRoles.map((r) => roleTableMap[r]()));

        await tx.userRole.createMany({
          data: roles.map((r) => ({ roleId: r, userId: user.id })),
        });

        if (branches?.length) {
          await tx.userBranch.createMany({
            data: branches.map((b) => ({ branchId: b, userId: user.id })),
          });
        }
      }

      const userDetails = await tx.user.findUnique({ where: { id: user.id } });
      return { user, userDetails };
    });

    await logActivity(
      req.username,
      needsApproval
        ? `FOR APPROVAL: ${req.username} created User ${username}`
        : `${req.username} created User ${username}`,
      branches[0]
    );

    return res.status(201).json({
      message: needsApproval
        ? "User created is awaiting approval"
        : "User is successfully created",
      data: needsApproval
        ? {
            username: result.user.payload.username,
            fullName: result.user.payload.fullName,
            ...(isContractor && { commission: Number(commission) }),
            ...(isEmployee && autoGenerated && { autoGenerated }),
          }
        : {
            userId: result.userDetails.id,
            username: result.userDetails.username,
            fullName: result.userDetails.fullName,
          },
    });
  } catch (err) {
    console.error(err.message);
    return res.status(500).json({ error: err.message });
  }
};


// PUT /:id
const editUsev = async (req, res) => {
  const parsedBody = parseArrayFields(req.body, ["roles", "branches"]);
  const { name, phone, email, description, roles, branches, remarks, autoGenerated } = parsedBody;
  const newImage = req.file ? req.file.filename : null;

  if (!req?.params?.id)
    return res.status(400).json({ message: "ID is required" });

  const user = await prisma.user.findFirst({ where: { id: req.params.id } });
  if (!user)
    return res
      .status(400)
      .json({ message: `User with ${req.params.id} doesn't exist` });

  try {
    let needsApproval = req.approval;
    let message = needsApproval
        ? "User edit awaiting approval"
        : "User edited successfully";
    
    if (roles) {
      const hasCustomerRole = await checkCustomerRole(prisma, roles);

      if (!hasCustomerRole && (!branches || branches.length === 0)) {
        return res
          .status(400)
          .json({ message: "Branches are required for non-customer users" });
      }
    }

    if (email && email !== user.email) {
      const existingUser = await prisma.user.findFirst({ where: { email, status:  "active", id: { not: req.params.id } } });
      const pendingUser = await checkPendingApproval(prisma, 'user', ['email'], email, req.params.id);
      const pendingJobOrderUser = await checkPendingApproval(prisma, 'jobOrder', ['customerData', 'email'], email, req.params.id);

      if (existingUser || pendingUser || pendingJobOrderUser) {
      return res
        .status(400)
        .json({ message: "Email already in use or pending approval" });
      }
    }

    let image = newImage ? newImage : user.image;

    if (!needsApproval) {
      if (newImage) {
        if (user.image) {
          deleteFile(`images/${user.image}`);
        }
        image = newImage;
      }
      // If frontend sent image: null or empty string → remove old image
      else if ((req.body.image === null || req.body.image === "") && user.image) {
        deleteFile(`images/${user.image}`);
        image = null;
      }
    }

    const updatedData = {
      fullName: name ?? user.fullName,
      username: user.username,
      phone: phone ?? user.phone,
      email: email ?? user.email,
      hashPwd: user.hashPwd,
      description: description ?? user.description,
      image,
      updatedByUser: req.username,
      ...(needsApproval ? { roles, branches } : {}),
    };

    const result = await prisma.$transaction(async (tx) => {
      const editedUser = needsApproval
        ? await requestApproval('user', req.params.id, 'edit', {
              ...updatedData,
              createdByUser: req.username }, req.username)
        : await tx.user.update({
            where: { id: user.id },
            data: updatedData,
          });

      const arraysEqual = (a, b) =>
        Array.isArray(a) &&
        Array.isArray(b) &&
        a.length === b.length &&
        [...a].sort().join(",") === [...b].sort().join(",");

      if (!needsApproval && roles && !arraysEqual(user.roles, roles)) {
        // STEP 1: Reset junction table roles
        await tx.userRole.deleteMany({ where: { userId: user.id } });

        await tx.userRole.createMany({
          data: roles.map((role) => ({ userId: user.id, roleId: role })),
        });

        // STEP 2: Clear old role-specific tables
        await Promise.all([
          tx.admin.deleteMany({ where: { userId: user.id } }),
          tx.customer.deleteMany({ where: { userId: user.id } }),
          tx.employee.deleteMany({ where: { userId: user.id } }),
          tx.contractor.deleteMany({ where: { userId: user.id } }),
        ]);

        // STEP 3: Recreate tables based on main roles (recursive)
        const roleTableMap = {
          [ROLES_LIST.ADMIN]: () => tx.admin.create({ data: { userId: user.id } }),
          [ROLES_LIST.CUSTOMER]: () => tx.customer.create({ data: { userId: user.id } }),
          [ROLES_LIST.EMPLOYEE]: () => {
            const autoGenerated = req.body.autoGenerated;

            if (!autoGenerated || typeof autoGenerated !== 'object') {
              return res.status(400).json({ message: "AutoPayment is required for employee and must be an object"})
            }

            if (!autoGenerated.branchId) {
              return res.status(400).json({ message: "branchId is required in AutoPayment"})
            }

            if (!autoGenerated.payComponents || !Array.isArray(autoGenerated.payComponents)) {
              return res.status(400).json({ message: "payComponents must be an array in AutoPayment"})
            }

            if (autoGenerated.payComponents.length === 0) {
              return res.status(400).json({ message: "payComponents cannot be empty in AutoPayment"})
            }

            if (autoGenerated.payComponents) {
              for (const component of autoGenerated.payComponents) {
                if (!component.componentId || !component.amount) {
                  return res.status(400).json({ message: "Each pay component must have componentId and amount"})
                }
              }
            };

            return tx.employee.update({
              where: { userId: user.id },
              data: { autoGenerated },
            });
          },
          [ROLES_LIST.CONTRACTOR]: () => {
            const commission = Number(req.body.commission);

            if (!commission) {
              return res.status(400).json({ message: "Commission is required"})
            }
            
            if (isNaN(commission)) {
              return res.status(400).json({ message: "Commission must be a valid number"})
            }

            if (commission > 1) {
              return res.status(400).json({ message: "Commission cannot be higher than 1 (100%)"})
            }

            if (commission < 0) {
              return res.status(400).json({ message: "Commission cannot be negative"})
            }

            return tx.contractor.create({
              data: { userId: user.id, commission },
            });
          },
        };

        // Determine main roles from roleIds recursively
        const roleNamesToCreateTables = await Promise.all(
          roles.map((roleId) => getMainBaseRole(prisma, roleId))
        );

        const uniqueRoleNames = [...new Set(roleNamesToCreateTables)].filter(Boolean);

        // Run mapped role table functions for main roles
        await Promise.all(
          uniqueRoleNames
            .filter((roleName) => roleTableMap[roleName])
            .map((roleName) => roleTableMap[roleName]())
        );
      }

      // STEP 4: Update branches if changed
      if (!needsApproval && branches && !arraysEqual(user.branches, branches)) {
        await tx.userBranch.deleteMany({ where: { userId: user.id } });
        await tx.userBranch.createMany({
          data: branches.map((branch) => ({ userId: user.id, branchId: branch })),
        });
      }

      const userDetails = await tx.user.findFirst({
        where: { id: editedUser.id },
        include: {
          roles: { include: { role: true } },
          branches: { include: { branch: true } },
        },
      });

      return { userDetails, user };
    });

    let safeUser;
    if (!needsApproval) {
      const { hashPwd: _, refreshToken, ...rest } = result.userDetails;
      safeUser = rest;
    };

    await logActivity(
      req.username,
      needsApproval
        ? `FOR APPROVAL: ${req.username} edited User ${updatedData.username}`
        : `${req.username} edited User ${updatedData.username}`,
        remarks
    );

    return res.status(201).json({
      message,
      data: needsApproval ? result.user : safeUser,
    });
  } catch (err) {
    console.log(err.message)
    return res.status(500).json({ error: err.message });
  }
};

const editUserNEWEST = async (req, res) => {
  const parsedBody = parseArrayFields(req.body, ["roles", "branches"]);
  const {
    name,
    phone,
    email,
    description,
    roles,
    branches,
    remarks,
    commission,
  } = parsedBody;
  const newImage = req.file ? req.file.filename : null;

  if (!req?.params?.id)
    return res.status(400).json({ message: "ID is required" });

  const user = await prisma.user.findFirst({
    where: { id: req.params.id },
    include: {
      roles: { include: { role: true } },
      contractor: true,
      employee: true,
    },
  });

  if (!user)
    return res
      .status(400)
      .json({ message: `User with ${req.params.id} doesn't exist` });

  try {
    let needsApproval = req.approval;
    let message = needsApproval
      ? "User edit awaiting approval"
      : "User edited successfully";

    // Get current role IDs for comparison
    const currentRoleIds = user.roles.map((role) => role.roleId);

    if (roles) {
      const hasCustomerRole = await checkCustomerRole(prisma, roles);

      if (!hasCustomerRole && (!branches || branches.length === 0)) {
        return res
          .status(400)
          .json({ message: "Branches are required for non-customer users" });
      }
    }

    if (email && email !== user.email) {
      const existingUser = await prisma.user.findFirst({
        where: { email, status: "active", id: { not: req.params.id } },
      });
      const pendingUser = await checkPendingApproval(
        prisma,
        "user",
        ["email"],
        email,
        req.params.id
      );
      const pendingJobOrderUser = await checkPendingApproval(
        prisma,
        "jobOrder",
        ["customerData", "email"],
        email,
        req.params.id
      );

      if (existingUser || pendingUser || pendingJobOrderUser) {
        return res
          .status(400)
          .json({ message: "Email already in use or pending approval" });
      }
    }

    let image = newImage ? newImage : user.image;

    if (!needsApproval) {
      if (newImage) {
        if (user.image) {
          deleteFile(`images/${user.image}`);
        }
        image = newImage;
      }
      // If frontend sent image: null or empty string → remove old image
      else if (
        (req.body.image === null || req.body.image === "") &&
        user.image
      ) {
        deleteFile(`images/${user.image}`);
        image = null;
      }
    }

    const updatedData = {
      fullName: name ?? user.fullName,
      username: user.username,
      phone: phone ?? user.phone,
      email: email ?? user.email,
      hashPwd: user.hashPwd,
      description: description ?? user.description,
      image,
      updatedByUser: req.username,
      ...(needsApproval ? { roles, branches } : {}),
    };

    const result = await prisma.$transaction(async (tx) => {
      const editedUser = needsApproval
        ? await requestApproval(
            "user",
            req.params.id,
            "edit",
            {
              ...updatedData,
              createdByUser: req.username,
            },
            req.username
          )
        : await tx.user.update({
            where: { id: user.id },
            data: updatedData,
          });

      const arraysEqual = (a, b) =>
        Array.isArray(a) &&
        Array.isArray(b) &&
        a.length === b.length &&
        [...a].sort().join(",") === [...b].sort().join(",");

      // ✅ Check if user is currently a contractor (using base roles)
      const currentBaseRoles = await Promise.all(
        currentRoleIds.map((roleId) => getMainBaseRole(prisma, roleId))
      );
      const isCurrentlyContractor = currentBaseRoles.includes(ROLES_LIST.CONTRACTOR);
      const isCurrentlyEmployee = currentBaseRoles.includes(ROLES_LIST.EMPLOYEE);

      // ✅ Check if user will be a contractor after role changes
      let willBeContractor = isCurrentlyContractor;
      if (roles && !arraysEqual(currentRoleIds, roles)) {
        const newBaseRoles = await Promise.all(
          roles.map((roleId) => getMainBaseRole(prisma, roleId))
        );
        willBeContractor = newBaseRoles.includes(ROLES_LIST.CONTRACTOR);
        willBeEmployee = newBaseRoles.includes(ROLES_LIST.EMPLOYEE);

      }

      // ✅ Handle commission updates for contractors
      if (!needsApproval && commission !== undefined) {
        if (willBeContractor) {
          const commissionValue = Number(commission);

          if (isNaN(commissionValue)) {
            throw new Error("Commission must be a valid number");
          }
          if (commissionValue > 1) {
            throw new Error("Commission cannot be higher than 1 (100%)");
          }
          if (commissionValue < 0) {
            throw new Error("Commission cannot be negative");
          }

          // Update or create contractor record
          if (user.contractor) {
            await tx.contractor.update({
              where: { userId: user.id },
              data: { commission: commissionValue },
            });
          } else {
            await tx.contractor.create({
              data: {
                userId: user.id,
                commission: commissionValue,
              },
            });
          }
        } else if (!user.contractor) {
          // Remove contractor record if user is no longer a contractor
          await tx.contractor.deleteMany({ where: { userId: user.id } });
        }
      }

      if (!needsApproval && autoGenerated !== undefined) {
        if (willBeEmployee) {
          const autoGeneratedValue = autoGenerated;

          if (!autoGeneratedValue || typeof autoGeneratedValue !== "object") {
            return res
              .status(400)
              .json({
                message:
                  "AutoPayment is required for employee and must be an object",
              });
          }

          if (!autoGeneratedValue.branchId) {
            return res
              .status(400)
              .json({ message: "branchId is required in AutoPayment" });
          }

          if (
            !autoGeneratedValue.payComponents ||
            !Array.isArray(autoGeneratedValue.payComponents)
          ) {
            return res
              .status(400)
              .json({
                message: "payComponents must be an array in AutoPayment",
              });
          }

          if (autoGeneratedValue.payComponents.length === 0) {
            return res
              .status(400)
              .json({
                message: "payComponents cannot be empty in AutoPayment",
              });
          }

          if (autoGeneratedValue.payComponents) {
            for (const component of autoGeneratedValue.payComponents) {
              if (!component.componentId || !component.amount) {
                return res
                  .status(400)
                  .json({
                    message:
                      "Each pay component must have componentId and amount",
                  });
              }
            }
          }

          // Update or create contractor record
          if (user.contractor) {
            await tx.employee.update({
              where: { userId: user.id },
              data: { autoGeneratedValue },
            });
          } else {
            await tx.employee.create({
              data: {
                userId: user.id,
                commission: autoGeneratedValue,
              },
            });
          }
        } else if (!user.employee) {
          // Remove contractor record if user is no longer a contractor
          await tx.employee.deleteMany({ where: { userId: user.id } });
        }
      }

      if (!needsApproval && roles && !arraysEqual(currentRoleIds, roles)) {
        // STEP 1: Reset junction table roles
        await tx.userRole.deleteMany({ where: { userId: user.id } });

        await tx.userRole.createMany({
          data: roles.map((role) => ({ userId: user.id, roleId: role })),
        });

        // STEP 2: Clear old role-specific tables
        await Promise.all([
          tx.admin.deleteMany({ where: { userId: user.id } }),
          tx.customer.deleteMany({ where: { userId: user.id } }),
          tx.employee.deleteMany({ where: { userId: user.id } }),
          tx.contractor.deleteMany({ where: { userId: user.id } }),
        ]);

        // STEP 3: Recreate tables based on main roles (using getMainBaseRole)
        const roleTableMap = {
          admin: () => tx.admin.create({ data: { userId: user.id } }),
          customer: () => tx.customer.create({ data: { userId: user.id } }),
          employee: () => {
            const autoGenerated = req.body.autoGenerated;

            return tx.employee.create({
              data: { userId: user.id, autoGenerated },
            });
          },
          contractor: () => {
            const commissionValue = Number(
              commission ?? user.contractor?.commission ?? 0
            );

            if (isNaN(commissionValue)) {
              throw new Error("Commission must be a valid number");
            }
            if (commissionValue > 1) {
              throw new Error("Commission cannot be higher than 1 (100%)");
            }
            if (commissionValue < 0) {
              throw new Error("Commission cannot be negative");
            }

            return tx.contractor.create({
              data: { userId: user.id, commission: commissionValue },
            });
          },
        };

        // Determine main roles from roleIds using getMainBaseRole
        const roleNamesToCreateTables = await Promise.all(
          roles.map((roleId) => getMainBaseRole(prisma, roleId))
        );

        const uniqueRoleNames = [...new Set(roleNamesToCreateTables)].filter(
          Boolean
        );

        // Run mapped role table functions for main roles
        await Promise.all(
          uniqueRoleNames
            .filter((roleName) => roleTableMap[roleName])
            .map((roleName) => roleTableMap[roleName]())
        );
      }

      // STEP 4: Update branches if changed
      if (!needsApproval && branches && !arraysEqual(user.branches, branches)) {
        await tx.userBranch.deleteMany({ where: { userId: user.id } });
        await tx.userBranch.createMany({
          data: branches.map((branch) => ({
            userId: user.id,
            branchId: branch,
          })),
        });
      }

      const userDetails = await tx.user.findFirst({
        where: { id: editedUser.id },
        include: {
          roles: { include: { role: true } },
          branches: { include: { branch: true } },
          contractor: true,
        },
      });

      return { userDetails, user };
    });

    let safeUser;
    if (!needsApproval) {
      const { hashPwd: _, refreshToken, ...rest } = result.userDetails;
      safeUser = rest;
    }

    await logActivity(
      req.username,
      needsApproval
        ? `FOR APPROVAL: ${req.username} edited User ${updatedData.username}`
        : `${req.username} edited User ${updatedData.username}`,
      remarks
    );

    updateScheduler();
    return res.status(201).json({
      message,
      data: needsApproval ? result.user : safeUser,
    });
  } catch (err) {
    console.log(err.message);
    return res.status(500).json({ error: err.message });
  }
};

const editUser55 = async (req, res) => {
  const parsedBody = parseArrayFields(req.body, ["roles", "branches"]);
  const {
    name,
    phone,
    email,
    description,
    roles,
    branches,
    remarks,
    commission,
    autoGenerated, // Add this
  } = parsedBody;
  const newImage = req.file ? req.file.filename : null;

  if (!req?.params?.id)
    return res.status(400).json({ message: "ID is required" });

  const user = await prisma.user.findFirst({
    where: { id: req.params.id },
    include: {
      roles: { include: { role: true } },
      contractor: true,
      employee: true,
    },
  });

  if (!user)
    return res
      .status(400)
      .json({ message: `User with ${req.params.id} doesn't exist` });

  try {
    let needsApproval = req.approval;
    let message = needsApproval
      ? "User edit awaiting approval"
      : "User edited successfully";

    // Get current role IDs for comparison
    const currentRoleIds = user.roles.map((role) => role.roleId);

    if (roles) {
      const hasCustomerRole = await checkCustomerRole(prisma, roles);

      if (!hasCustomerRole && (!branches || branches.length === 0)) {
        return res
          .status(400)
          .json({ message: "Branches are required for non-customer users" });
      }
    }

    if (email && email !== user.email) {
      const existingUser = await prisma.user.findFirst({
        where: { email, status: "active", id: { not: req.params.id } },
      });
      const pendingUser = await checkPendingApproval(
        prisma,
        "user",
        ["email"],
        email,
        req.params.id
      );
      const pendingJobOrderUser = await checkPendingApproval(
        prisma,
        "jobOrder",
        ["customerData", "email"],
        email,
        req.params.id
      );

      if (existingUser || pendingUser || pendingJobOrderUser) {
        return res
          .status(400)
          .json({ message: "Email already in use or pending approval" });
      }
    }

    let image = newImage ? newImage : user.image;

    if (!needsApproval) {
      if (newImage) {
        if (user.image) {
          deleteFile(`images/${user.image}`);
        }
        image = newImage;
      }
      // If frontend sent image: null or empty string → remove old image
      else if (
        (req.body.image === null || req.body.image === "") &&
        user.image
      ) {
        deleteFile(`images/${user.image}`);
        image = null;
      }
    }

    const updatedData = {
      fullName: name ?? user.fullName,
      username: user.username,
      phone: phone ?? user.phone,
      email: email ?? user.email,
      hashPwd: user.hashPwd,
      description: description ?? user.description,
      image,
      updatedByUser: req.username,
      ...(needsApproval ? { roles, branches } : {}),
    };

    const result = await prisma.$transaction(async (tx) => {
      const editedUser = needsApproval
        ? await requestApproval(
            "user",
            req.params.id,
            "edit",
            {
              ...updatedData,
              createdByUser: req.username,
            },
            req.username
          )
        : await tx.user.update({
            where: { id: user.id },
            data: updatedData,
          });

      const arraysEqual = (a, b) =>
        Array.isArray(a) &&
        Array.isArray(b) &&
        a.length === b.length &&
        [...a].sort().join(",") === [...b].sort().join(",");

      // Check current and future roles
      const currentBaseRoles = await Promise.all(
        currentRoleIds.map((roleId) => getMainBaseRole(prisma, roleId))
      );
      const isCurrentlyContractor = currentBaseRoles.includes(
        ROLES_LIST.CONTRACTOR
      );
      const isCurrentlyEmployee = currentBaseRoles.includes(
        ROLES_LIST.EMPLOYEE
      );

      let willBeContractor = isCurrentlyContractor;
      let willBeEmployee = isCurrentlyEmployee;

      if (roles && !arraysEqual(currentRoleIds, roles)) {
        const newBaseRoles = await Promise.all(
          roles.map((roleId) => getMainBaseRole(prisma, roleId))
        );
        willBeContractor = newBaseRoles.includes(ROLES_LIST.CONTRACTOR);
        willBeEmployee = newBaseRoles.includes(ROLES_LIST.EMPLOYEE);
      }

      // Handle commission updates for contractors
      if (!needsApproval && commission !== undefined) {
        if (willBeContractor) {
          const commissionValue = Number(commission);

          if (isNaN(commissionValue)) {
            throw new Error("Commission must be a valid number");
          }
          if (commissionValue > 1) {
            throw new Error("Commission cannot be higher than 1 (100%)");
          }
          if (commissionValue < 0) {
            throw new Error("Commission cannot be negative");
          }

          // Update or create contractor record
          if (user.contractor) {
            await tx.contractor.update({
              where: { userId: user.id },
              data: { commission: commissionValue },
            });
          } else {
            await tx.contractor.create({
              data: {
                userId: user.id,
                commission: commissionValue,
              },
            });
          }
        } else if (
          isCurrentlyContractor &&
          !willBeContractor &&
          user.contractor
        ) {
          // Remove contractor record if user is no longer a contractor
          await tx.contractor
            .delete({ where: { userId: user.id } })
            .catch(() => {
              console.log("Could not delete contractor, keeping record");
            });
        }
      }

      // Handle autoGenerated updates for employees
      if (!needsApproval && autoGenerated !== undefined) {
        if (willBeEmployee) {
          const autoGeneratedValue = autoGenerated;

          if (autoGeneratedValue === null) {
            // Allow null to clear autoGenerated
            if (user.employee) {
              await tx.employee.update({
                where: { userId: user.id },
                data: { autoGenerated: null },
              });
            }
          } else if (typeof autoGeneratedValue !== "object") {
            return res.status(400).json({
              message: "AutoGenerated must be an object or null",
            });
          } else {
            // Basic validation
            if (
              !autoGeneratedValue.branchId ||
              !autoGeneratedValue.payComponents
            ) {
              return res.status(400).json({
                message: "autoGenerated must have branchId and payComponents",
              });
            }

            // Update or create employee record
            if (user.employee) {
              await tx.employee.update({
                where: { userId: user.id },
                data: { autoGenerated: autoGeneratedValue },
              });
            } else {
              await tx.employee.create({
                data: {
                  userId: user.id,
                  autoGenerated: autoGeneratedValue,
                },
              });
            }
          }
        } else if (isCurrentlyEmployee && !willBeEmployee && user.employee) {
          // Remove employee record if user is no longer an employee
          await tx.employee.delete({ where: { userId: user.id } }).catch(() => {
            console.log("Could not delete employee, keeping record");
          });
        }
      }

      // Handle role changes
      if (!needsApproval && roles && !arraysEqual(currentRoleIds, roles)) {
        // STEP 1: Reset junction table roles
        await tx.userRole.deleteMany({ where: { userId: user.id } });

        await tx.userRole.createMany({
          data: roles.map((role) => ({ userId: user.id, roleId: role })),
        });

        // STEP 2: Get new base roles
        const newBaseRoles = await Promise.all(
          roles.map((roleId) => getMainBaseRole(prisma, roleId))
        );

        // STEP 3: Handle each role table individually
        const roleHandlers = {
          [ROLES_LIST.ADMIN]: async () => {
            if (newBaseRoles.includes(ROLES_LIST.ADMIN)) {
              const existing = await tx.admin.findUnique({
                where: { userId: user.id },
              });
              if (!existing) {
                await tx.admin.create({ data: { userId: user.id } });
              }
            } else {
              await tx.admin
                .delete({ where: { userId: user.id } })
                .catch(() => {});
            }
          },
          [ROLES_LIST.CUSTOMER]: async () => {
            if (newBaseRoles.includes(ROLES_LIST.CUSTOMER)) {
              const existing = await tx.customer.findUnique({
                where: { userId: user.id },
              });
              if (!existing) {
                await tx.customer.create({ data: { userId: user.id } });
              }
            } else {
              await tx.customer
                .delete({ where: { userId: user.id } })
                .catch(() => {});
            }
          },
          [ROLES_LIST.EMPLOYEE]: async () => {
            if (newBaseRoles.includes(ROLES_LIST.EMPLOYEE)) {
              const existing = await tx.employee.findUnique({
                where: { userId: user.id },
              });
              if (!existing) {
                await tx.employee.create({
                  data: {
                    userId: user.id,
                    ...(autoGenerated !== undefined && { autoGenerated }),
                  },
                });
              } else if (autoGenerated !== undefined) {
                await tx.employee.update({
                  where: { userId: user.id },
                  data: { autoGenerated },
                });
              }
            } else {
              await tx.employee
                .delete({ where: { userId: user.id } })
                .catch(() => {});
            }
          },
          [ROLES_LIST.CONTRACTOR]: async () => {
            if (newBaseRoles.includes(ROLES_LIST.CONTRACTOR)) {
              const existing = await tx.contractor.findUnique({
                where: { userId: user.id },
              });
              const commissionValue = Number(
                commission || existing?.commission || 0
              );

              if (!existing) {
                await tx.contractor.create({
                  data: {
                    userId: user.id,
                    commission: commissionValue,
                  },
                });
              } else if (commission !== undefined) {
                await tx.contractor.update({
                  where: { userId: user.id },
                  data: { commission: commissionValue },
                });
              }
            } else {
              await tx.contractor
                .delete({ where: { userId: user.id } })
                .catch(() => {});
            }
          },
        };

        // Execute role handlers
        const allRoleHandlers = [
          ROLES_LIST.ADMIN,
          ROLES_LIST.CUSTOMER,
          ROLES_LIST.EMPLOYEE,
          ROLES_LIST.CONTRACTOR,
        ].map((role) => roleHandlers[role]?.());

        await Promise.all(allRoleHandlers);
      }

      // STEP 4: Update branches if changed
      if (!needsApproval && branches && !arraysEqual(user.branches, branches)) {
        await tx.userBranch.deleteMany({ where: { userId: user.id } });
        await tx.userBranch.createMany({
          data: branches.map((branch) => ({
            userId: user.id,
            branchId: branch,
          })),
        });
      }

      const userDetails = await tx.user.findFirst({
        where: { id: editedUser.id },
        include: {
          roles: { include: { role: true } },
          branches: { include: { branch: true } },
          contractor: true,
          employee: true,
        },
      });

      return { userDetails, user };
    });

    let safeUser;
    if (!needsApproval) {
      const { hashPwd: _, refreshToken, ...rest } = result.userDetails;
      safeUser = rest;
    }

    await logActivity(
      req.username,
      needsApproval
        ? `FOR APPROVAL: ${req.username} edited User ${updatedData.username}`
        : `${req.username} edited User ${updatedData.username}`,
      remarks
    );

    // Remove updateScheduler() - cron job handles it
    // updateScheduler();

    return res.status(201).json({
      message,
      data: needsApproval ? result.user : safeUser,
    });
  } catch (err) {
    console.log(err.message);
    return res.status(500).json({ error: err.message });
  }
};

const editUserWithoutCOmponentCreate = async (req, res) => {
  const parsedBody = parseArrayFields(req.body, [
    "roles",
    "branches",
    "autoGenerated",
  ]);
  const {
    name,
    phone,
    email,
    description,
    roles,
    branches,
    remarks,
    commission,
    autoGenerated,
  } = parsedBody;
  const newImage = req.file ? req.file.filename : null;

  if (!req?.params?.id)
    return res.status(400).json({ message: "ID is required" });

  const user = await prisma.user.findFirst({
    where: { id: req.params.id },
    include: {
      roles: { include: { role: true } },
      contractor: true,
      employee: true,
      admin: true,
      customer: true,
    },
  });

  if (!user)
    return res
      .status(400)
      .json({ message: `User with ${req.params.id} doesn't exist` });

  try {
    let needsApproval = req.approval;
    let message = needsApproval
      ? "User edit awaiting approval"
      : "User edited successfully";

    // Get current role IDs for comparison
    const currentRoleIds = user.roles.map((role) => role.roleId);

    if (roles) {
      const hasCustomerRole = await checkCustomerRole(prisma, roles);

      if (!hasCustomerRole && (!branches || branches.length === 0)) {
        return res
          .status(400)
          .json({ message: "Branches are required for non-customer users" });
      }
    }

    if (email && email !== user.email) {
      const existingUser = await prisma.user.findFirst({
        where: { email, status: "active", id: { not: req.params.id } },
      });
      const pendingUser = await checkPendingApproval(
        prisma,
        "user",
        ["email"],
        email,
        req.params.id
      );
      const pendingJobOrderUser = await checkPendingApproval(
        prisma,
        "jobOrder",
        ["customerData", "email"],
        email,
        req.params.id
      );

      if (existingUser || pendingUser || pendingJobOrderUser) {
        return res
          .status(400)
          .json({ message: "Email already in use or pending approval" });
      }
    }

    let image = newImage ? newImage : user.image;

    if (!needsApproval) {
      if (newImage) {
        if (user.image) {
          deleteFile(`images/${user.image}`);
        }
        image = newImage;
      }
      // If frontend sent image: null or empty string → remove old image
      else if (
        (req.body.image === null || req.body.image === "") &&
        user.image
      ) {
        deleteFile(`images/${user.image}`);
        image = null;
      }
    }

    // Determine if user will be employee/contractor after role changes
    let willBeEmployee = false;
    let willBeContractor = false;

    if (roles) {
      const roleBaseNames = await Promise.all(
        roles.map((roleId) => getMainBaseRole(prisma, roleId))
      );
      willBeEmployee = roleBaseNames.includes(ROLES_LIST.EMPLOYEE);
      willBeContractor = roleBaseNames.includes(ROLES_LIST.CONTRACTOR);
    } else {
      // If roles not being changed, check current roles
      const currentBaseRoles = await Promise.all(
        currentRoleIds.map((roleId) => getMainBaseRole(prisma, roleId))
      );
      willBeEmployee = currentBaseRoles.includes(ROLES_LIST.EMPLOYEE);
      willBeContractor = currentBaseRoles.includes(ROLES_LIST.CONTRACTOR);
    }

    // Validate autoGenerated if provided and user will be employee
    if (autoGenerated !== undefined && willBeEmployee) {
      if (autoGenerated === null) {
        // Allow null to clear autoGenerated
      } else if (typeof autoGenerated !== "object") {
        return res.status(400).json({
          message: "AutoGenerated must be an object or null",
        });
      } else {
        // Basic validation
        if (!autoGenerated.branchId || !autoGenerated.payComponents) {
          return res.status(400).json({
            message: "autoGenerated must have branchId and payComponents",
          });
        }
      }
    }

    // Validate commission if provided and user will be contractor
    if (commission !== undefined && willBeContractor) {
      const commissionValue = Number(commission);
      if (isNaN(commissionValue)) {
        return res.status(400).json({
          message: "Commission must be a valid number",
        });
      }
      if (commissionValue > 1) {
        return res.status(400).json({
          message: "Commission cannot be higher than 1 (100%)",
        });
      }
      if (commissionValue < 0) {
        return res.status(400).json({
          message: "Commission cannot be negative",
        });
      }
    }

    // Build updated data - include autoGenerated and commission in approval payload
    const updatedData = {
      fullName: name ?? user.fullName,
      username: user.username,
      phone: phone ?? user.phone,
      email: email ?? user.email,
      hashPwd: user.hashPwd,
      description: description ?? user.description,
      image,
      updatedByUser: req.username,
      ...(needsApproval
        ? {
            roles: roles || currentRoleIds,
            branches: branches || user.branches,
            ...(willBeContractor &&
              commission !== undefined && { commission: Number(commission) }),
            ...(willBeEmployee &&
              autoGenerated !== undefined && { autoGenerated }),
          }
        : {}),
    };

    const result = await prisma.$transaction(async (tx) => {
      const editedUser = needsApproval
        ? await requestApproval(
            "user",
            req.params.id,
            "edit",
            {
              ...updatedData,
              createdByUser: req.username,
            },
            req.username,
            branches[0]
          )
        : await tx.user.update({
            where: { id: user.id },
            data: updatedData,
          });

      // For non-approval flow, handle the updates directly
      if (!needsApproval) {
        const arraysEqual = (a, b) =>
          Array.isArray(a) &&
          Array.isArray(b) &&
          a.length === b.length &&
          [...a].sort().join(",") === [...b].sort().join(",");

        // Check current base roles
        const currentBaseRoles = await Promise.all(
          currentRoleIds.map((roleId) => getMainBaseRole(prisma, roleId))
        );

        // Handle role changes
        if (roles && !arraysEqual(currentRoleIds, roles)) {
          // Update userRole junction table
          await tx.userRole.deleteMany({ where: { userId: user.id } });
          await tx.userRole.createMany({
            data: roles.map((role) => ({ userId: user.id, roleId: role })),
          });

          // Get new base roles
          const newBaseRoles = await Promise.all(
            roles.map((roleId) => getMainBaseRole(prisma, roleId))
          );

          // Handle each role table with upsert to avoid foreign key constraints
          const roleHandlers = {
            [ROLES_LIST.ADMIN]: async () => {
              if (newBaseRoles.includes(ROLES_LIST.ADMIN)) {
                await tx.admin.upsert({
                  where: { userId: user.id },
                  update: {},
                  create: { userId: user.id },
                });
              } else if (user.admin) {
                await tx.admin
                  .delete({ where: { userId: user.id } })
                  .catch(() => {});
              }
            },
            [ROLES_LIST.CUSTOMER]: async () => {
              if (newBaseRoles.includes(ROLES_LIST.CUSTOMER)) {
                await tx.customer.upsert({
                  where: { userId: user.id },
                  update: {},
                  create: { userId: user.id },
                });
              } else if (user.customer) {
                await tx.customer
                  .delete({ where: { userId: user.id } })
                  .catch(() => {});
              }
            },
            [ROLES_LIST.EMPLOYEE]: async () => {
              if (newBaseRoles.includes(ROLES_LIST.EMPLOYEE)) {
                await tx.employee.upsert({
                  where: { userId: user.id },
                  update: {
                    ...(autoGenerated !== undefined && { autoGenerated }),
                  },
                  create: {
                    userId: user.id,
                    ...(autoGenerated !== undefined && { autoGenerated }),
                  },
                });
              } else if (user.employee) {
                await tx.employee
                  .delete({ where: { userId: user.id } })
                  .catch(() => {});
              }
            },
            [ROLES_LIST.CONTRACTOR]: async () => {
              if (newBaseRoles.includes(ROLES_LIST.CONTRACTOR)) {
                const commissionValue = Number(
                  commission || user.contractor?.commission || 0
                );
                await tx.contractor.upsert({
                  where: { userId: user.id },
                  update: { commission: commissionValue },
                  create: {
                    userId: user.id,
                    commission: commissionValue,
                  },
                });
              } else if (user.contractor) {
                await tx.contractor
                  .delete({ where: { userId: user.id } })
                  .catch(() => {});
              }
            },
          };

          // Execute role handlers
          await Promise.all([
            roleHandlers[ROLES_LIST.ADMIN]?.(),
            roleHandlers[ROLES_LIST.CUSTOMER]?.(),
            roleHandlers[ROLES_LIST.EMPLOYEE]?.(),
            roleHandlers[ROLES_LIST.CONTRACTOR]?.(),
          ]);
        }

        // Handle autoGenerated update without role change
        if (autoGenerated !== undefined && !roles && willBeEmployee) {
          if (user.employee) {
            await tx.employee.update({
              where: { userId: user.id },
              data: { autoGenerated },
            });
          } else {
            await tx.employee.create({
              data: {
                userId: user.id,
                autoGenerated,
              },
            });
          }
        }

        // Handle commission update without role change
        if (commission !== undefined && !roles && willBeContractor) {
          const commissionValue = Number(commission);
          if (user.contractor) {
            await tx.contractor.update({
              where: { userId: user.id },
              data: { commission: commissionValue },
            });
          } else {
            await tx.contractor.create({
              data: {
                userId: user.id,
                commission: commissionValue,
              },
            });
          }
        }

        // Update branches if changed
        if (branches && !arraysEqual(user.branches, branches)) {
          await tx.userBranch.deleteMany({ where: { userId: user.id } });
          await tx.userBranch.createMany({
            data: branches.map((branch) => ({
              userId: user.id,
              branchId: branch,
            })),
          });
        }
      }

      const userDetails = await tx.user.findFirst({
        where: { id: editedUser.id },
        include: {
          roles: { include: { role: true } },
          branches: { include: { branch: true } },
          contractor: true,
          employee: true,
          admin: true,
          customer: true,
        },
      });

      return { userDetails, user };
    });

    let safeUser;
    if (!needsApproval) {
      const { hashPwd: _, refreshToken, ...rest } = result.userDetails;
      safeUser = rest;
    }

    await logActivity(
      req.username,
      needsApproval
        ? `FOR APPROVAL: ${req.username} edited User ${updatedData.username}`
        : `${req.username} edited User ${updatedData.username}`,
      remarks
    );

    return res.status(201).json({
      message,
      data: needsApproval ? result.user : safeUser,
    });
  } catch (err) {
    console.log(err.message);
    return res.status(500).json({ error: err.message });
  }
};

const editUser = async (req, res) => {
  const parsedBody = parseArrayFields(req.body, [
    "roles",
    "branches",
    "autoGenerated",
  ]);
  const {
    name,
    phone,
    email,
    description,
    roles,
    branches,
    remarks,
    commission,
    autoGenerated,
  } = parsedBody;
  const newImage = req.file ? req.file.filename : null;

  if (!req?.params?.id)
    return res.status(400).json({ message: "ID is required" });

  const user = await prisma.user.findFirst({
    where: { id: req.params.id },
    include: {
      roles: { include: { role: true } },
      contractor: true,
      employee: true,
      admin: true,
      customer: true,
    },
  });

  if (!user)
    return res
      .status(400)
      .json({ message: `User with ${req.params.id} doesn't exist` });

  try {
    let needsApproval = req.approval;
    let message = needsApproval
      ? "User edit awaiting approval"
      : "User edited successfully";

    const currentRoleIds = user.roles.map((role) => role.roleId);

    if (roles) {
      const hasCustomerRole = await checkCustomerRole(prisma, roles);

      if (!hasCustomerRole && (!branches || branches.length === 0)) {
        return res
          .status(400)
          .json({ message: "Branches are required for non-customer users" });
      }
    }

    if (email && email !== user.email) {
      const existingUser = await prisma.user.findFirst({
        where: { email, status: "active", id: { not: req.params.id } },
      });
      const pendingUser = await checkPendingApproval(
        prisma,
        "user",
        ["email"],
        email,
        req.params.id
      );
      const pendingJobOrderUser = await checkPendingApproval(
        prisma,
        "jobOrder",
        ["customerData", "email"],
        email,
        req.params.id
      );

      if (existingUser || pendingUser || pendingJobOrderUser) {
        return res
          .status(400)
          .json({ message: "Email already in use or pending approval" });
      }
    }

    let image = newImage ? newImage : user.image;

    if (!needsApproval) {
      if (newImage) {
        if (user.image) deleteFile(`images/${user.image}`);
        image = newImage;
      } else if (
        (req.body.image === null || req.body.image === "") &&
        user.image
      ) {
        deleteFile(`images/${user.image}`);
        image = null;
      }
    }

    let willBeEmployee = false;
    let willBeContractor = false;

    if (roles) {
      const roleBaseNames = await Promise.all(
        roles.map((roleId) => getMainBaseRole(prisma, roleId))
      );
      willBeEmployee = roleBaseNames.includes(ROLES_LIST.EMPLOYEE);
      willBeContractor = roleBaseNames.includes(ROLES_LIST.CONTRACTOR);
    } else {
      const currentBaseRoles = await Promise.all(
        currentRoleIds.map((roleId) => getMainBaseRole(prisma, roleId))
      );
      willBeEmployee = currentBaseRoles.includes(ROLES_LIST.EMPLOYEE);
      willBeContractor = currentBaseRoles.includes(ROLES_LIST.CONTRACTOR);
    }

    if (autoGenerated !== undefined && willBeEmployee) {
      if (autoGenerated === null) {
        // Allow null to clear autoGenerated
      } else if (typeof autoGenerated !== "object") {
        return res.status(400).json({
          message: "AutoGenerated must be an object or null",
        });
      } else if (!autoGenerated.branchId || !autoGenerated.payComponents) {
        return res.status(400).json({
          message: "autoGenerated must have branchId and payComponents",
        });
      }
    }

    if (commission !== undefined && willBeContractor) {
      const commissionValue = Number(commission);
      if (
        isNaN(commissionValue) ||
        commissionValue < 0 ||
        commissionValue > 1
      ) {
        return res.status(400).json({
          message: "Commission must be a number between 0 and 1",
        });
      }
    }

    const updatedData = {
      fullName: name ?? user.fullName,
      username: user.username,
      phone: phone ?? user.phone,
      email: email ?? user.email,
      hashPwd: user.hashPwd,
      description: description ?? user.description,
      image,
      updatedByUser: req.username,
      ...(needsApproval
        ? {
            roles: roles || currentRoleIds,
            branches: branches || user.branches,
            ...(willBeContractor &&
              commission !== undefined && { commission: Number(commission) }),
            ...(willBeEmployee &&
              autoGenerated !== undefined && { autoGenerated }),
          }
        : {}),
    };

    const result = await prisma.$transaction(async (tx) => {
      const editedUser = needsApproval
        ? await requestApproval(
            "user",
            req.params.id,
            "edit",
            { ...updatedData, createdByUser: req.username },
            req.username,
            branches?.[0] || null
          )
        : await tx.user.update({
            where: { id: user.id },
            data: updatedData,
          });

      // ===== Normalize autoGenerated payComponents =====
      let normalizedAutoGenerated = autoGenerated;
      if (
        !needsApproval &&
        willBeEmployee &&
        autoGenerated?.payComponents?.length
      ) {
        const normalizedComponents = await Promise.all(
          autoGenerated.payComponents.map(async (pc) => {
            if (pc.componentId) {
              const existing = await tx.component.findUnique({
                where: { id: pc.componentId },
              });
              if (existing) return pc;
            }

            if (!pc.componentName)
              throw new Error(
                "componentName is required for new pay components"
              );

            let component = await tx.component.findFirst({
              where: { componentName: pc.componentName },
            });

            if (!component) {
              component = await tx.component.create({
                data: { componentName: pc.componentName },
              });
            }

            return { ...pc, componentId: component.id };
          })
        );

        normalizedAutoGenerated = {
          ...autoGenerated,
          payComponents: normalizedComponents,
        };

        if (user.employee) {
          await tx.employee.update({
            where: { userId: user.id },
            data: { autoGenerated: normalizedAutoGenerated },
          });
        } else {
          await tx.employee.create({
            data: { userId: user.id, autoGenerated: normalizedAutoGenerated },
          });
        }
      }

      const userDetails = await tx.user.findFirst({
        where: { id: editedUser.id },
        include: {
          roles: { include: { role: true } },
          branches: { include: { branch: true } },
          contractor: true,
          employee: true,
          admin: true,
          customer: true,
        },
      });

      return { userDetails, normalizedAutoGenerated };
    });

    let safeUser;
    if (!needsApproval) {
      const { hashPwd: _, refreshToken, ...rest } = result.userDetails;
      safeUser = rest;
      if (result.normalizedAutoGenerated) {
        safeUser.employee.autoGenerated = result.normalizedAutoGenerated;
      }
    }

    await logActivity(
      req.username,
      needsApproval
        ? `FOR APPROVAL: ${req.username} edited User ${updatedData.username}`
        : `${req.username} edited User ${updatedData.username}`,
      remarks
    );

    return res.status(201).json({
      message,
      data: needsApproval ? result.user : safeUser,
    });
  } catch (err) {
    console.log(err.message);
    return res.status(500).json({ error: err.message });
  }
};



const editUserNew = async (req, res) => {
  const parsedBody = parseArrayFields(req.body, ["roles", "branches"]);
  const {
    name,
    phone,
    email,
    description,
    roles,
    branches,
    remarks,
    commission,
    autoGenerated, // Add autoGenerated here
  } = parsedBody;

  const newImage = req.file ? req.file.filename : null;

  if (!req?.params?.id)
    return res.status(400).json({ message: "ID is required" });

  const user = await prisma.user.findFirst({
    where: { id: req.params.id },
    include: {
      roles: { include: { role: true } },
      contractor: true,
      employee: true, // Include employee to check existing autoGenerated
    },
  });

  if (!user)
    return res
      .status(400)
      .json({ message: `User with ${req.params.id} doesn't exist` });

  try {
    let needsApproval = req.approval;
    let message = needsApproval
      ? "User edit awaiting approval"
      : "User edited successfully";

    // Get current role IDs for comparison
    const currentRoleIds = user.roles.map((role) => role.roleId);

    // Pre-fetch role base names for validation
    let roleBaseNames = [];
    if (roles) {
      roleBaseNames = await Promise.all(
        roles.map((roleId) => getMainBaseRole(prisma, roleId))
      );

      const hasCustomerRole = roleBaseNames.includes(ROLES_LIST.CUSTOMER);
      const isEmployee = roleBaseNames.includes(ROLES_LIST.EMPLOYEE);
      const isContractor = roleBaseNames.includes(ROLES_LIST.CONTRACTOR);

      if (!hasCustomerRole && (!branches || branches.length === 0)) {
        return res
          .status(400)
          .json({ message: "Branches are required for non-customer users" });
      }

      // Validate commission if contractor role is selected
      if (isContractor) {
        const commissionValue = Number(commission);

        if (commission === undefined || commission === null) {
          return res
            .status(400)
            .json({ message: "Commission is required for contractor" });
        }

        if (isNaN(commissionValue)) {
          return res
            .status(400)
            .json({ message: "Commission must be a valid number" });
        }

        if (commissionValue > 1) {
          return res
            .status(400)
            .json({ message: "Commission cannot be higher than 1 (100%)" });
        }

        if (commissionValue < 0) {
          return res
            .status(400)
            .json({ message: "Commission cannot be negative" });
        }
      }

      // Validate autoGenerated if employee role is selected
      if (isEmployee) {
        if (!autoGenerated && !user.employee?.autoGenerated) {
          return res
            .status(400)
            .json({ message: "autoGenerated is required for employee role" });
        }

        // Validate that autoGenerated is a valid JSON object/array if provided
        if (autoGenerated) {
          try {
            let parsedAutoGenerated = autoGenerated;

            if (typeof autoGenerated === "string") {
              parsedAutoGenerated = JSON.parse(autoGenerated);
            }

            if (!Array.isArray(parsedAutoGenerated)) {
              return res
                .status(400)
                .json({ message: "autoGenerated must be a valid JSON array" });
            }

            const isValidStructure = parsedAutoGenerated.every(
              (item) =>
                item &&
                typeof item === "object" &&
                item.component_id &&
                item.schedules &&
                Array.isArray(item.schedules)
            );

            if (!isValidStructure) {
              return res.status(400).json({
                message:
                  "autoGenerated must contain objects with 'component_id' and 'schedules' array",
              });
            }
          } catch (error) {
            return res
              .status(400)
              .json({ message: "autoGenerated must be a valid JSON format" });
          }
        }
      }
    }

    if (email && email !== user.email) {
      const existingUser = await prisma.user.findFirst({
        where: { email, status: "active", id: { not: req.params.id } },
      });
      const pendingUser = await checkPendingApproval(
        prisma,
        "user",
        ["email"],
        email,
        req.params.id
      );
      const pendingJobOrderUser = await checkPendingApproval(
        prisma,
        "jobOrder",
        ["customerData", "email"],
        email,
        req.params.id
      );

      if (existingUser || pendingUser || pendingJobOrderUser) {
        return res
          .status(400)
          .json({ message: "Email already in use or pending approval" });
      }
    }

    let image = newImage ? newImage : user.image;

    if (!needsApproval) {
      if (newImage) {
        if (user.image) {
          deleteFile(`images/${user.image}`);
        }
        image = newImage;
      }
      // If frontend sent image: null or empty string → remove old image
      else if (
        (req.body.image === null || req.body.image === "") &&
        user.image
      ) {
        deleteFile(`images/${user.image}`);
        image = null;
      }
    }

    // Process autoGenerated for storage
    let processedAutoGenerated = null;
    if (autoGenerated) {
      processedAutoGenerated =
        typeof autoGenerated === "string"
          ? JSON.parse(autoGenerated)
          : autoGenerated;
    }

    const updatedData = {
      fullName: name ?? user.fullName,
      username: user.username,
      phone: phone ?? user.phone,
      email: email ?? user.email,
      hashPwd: user.hashPwd,
      description: description ?? user.description,
      image,
      updatedByUser: req.username,
      ...(needsApproval
        ? {
            roles,
            branches,
            ...(roleBaseNames.includes(ROLES_LIST.CONTRACTOR) && {
              commission: Number(commission),
            }),
            ...(roleBaseNames.includes(ROLES_LIST.EMPLOYEE) && {
              autoGenerated: processedAutoGenerated,
            }),
          }
        : {}),
    };

    const result = await prisma.$transaction(async (tx) => {
      const editedUser = needsApproval
        ? await requestApproval(
            "user",
            req.params.id,
            "edit",
            {
              ...updatedData,
              createdByUser: req.username,
            },
            req.username
          )
        : await tx.user.update({
            where: { id: user.id },
            data: updatedData,
          });

      const arraysEqual = (a, b) =>
        Array.isArray(a) &&
        Array.isArray(b) &&
        a.length === b.length &&
        [...a].sort().join(",") === [...b].sort().join(",");

      // ✅ Check if user is currently a contractor (using base roles)
      const currentBaseRoles = await Promise.all(
        currentRoleIds.map((roleId) => getMainBaseRole(prisma, roleId))
      );
      const isCurrentlyContractor = currentBaseRoles.includes(ROLES_LIST.CONTRACTOR);
      const isCurrentlyEmployee = currentBaseRoles.includes(ROLES_LIST.EMPLOYEE);

      // ✅ Check if user will be a contractor/employee after role changes
      let willBeContractor = isCurrentlyContractor;
      let willBeEmployee = isCurrentlyEmployee;
      if (roles && !arraysEqual(currentRoleIds, roles)) {
        const newBaseRoles = await Promise.all(
          roles.map((roleId) => getMainBaseRole(prisma, roleId))
        );
        willBeContractor = newBaseRoles.includes(ROLES_LIST.CONTRACTOR);
        willBeEmployee = newBaseRoles.includes(ROLES_LIST.EMPLOYEE);
      }

      // ✅ Handle commission and autoGenerated updates for direct edits (no approval needed)
      if (!needsApproval) {
        // Handle commission updates for contractors
        if (commission !== undefined) {
          if (willBeContractor) {
            const commissionValue = Number(commission);

            if (isNaN(commissionValue)) {
              throw new Error("Commission must be a valid number");
            }
            if (commissionValue > 1) {
              throw new Error("Commission cannot be higher than 1 (100%)");
            }
            if (commissionValue < 0) {
              throw new Error("Commission cannot be negative");
            }

            // Update or create contractor record
            if (user.contractor) {
              await tx.contractor.update({
                where: { userId: user.id },
                data: { commission: commissionValue },
              });
            } else {
              await tx.contractor.create({
                data: {
                  userId: user.id,
                  commission: commissionValue,
                },
              });
            }
          } else if (user.contractor) {
            // Remove contractor record if user is no longer a contractor
            await tx.contractor.deleteMany({ where: { userId: user.id } });
          }
        }

        // Handle autoGenerated updates for employees
        if (autoGenerated !== undefined) {
          if (willBeEmployee) {
            // Update or create employee record with autoGenerated
            if (user.employee) {
              await tx.employee.update({
                where: { userId: user.id },
                data: { autoGenerated: processedAutoGenerated },
              });
            } else {
              await tx.employee.create({
                data: {
                  userId: user.id,
                  autoGenerated: processedAutoGenerated,
                },
              });
            }
          } else if (user.employee) {
            // Remove autoGenerated if user is no longer an employee
            await tx.employee.update({
              where: { userId: user.id },
              data: { autoGenerated: null },
            });
          }
        }
      }

      if (!needsApproval && roles && !arraysEqual(currentRoleIds, roles)) {
        // STEP 1: Reset junction table roles
        await tx.userRole.deleteMany({ where: { userId: user.id } });

        await tx.userRole.createMany({
          data: roles.map((role) => ({ userId: user.id, roleId: role })),
        });

        // STEP 2: Clear old role-specific tables
        await Promise.all([
          tx.admin.deleteMany({ where: { userId: user.id } }),
          tx.customer.deleteMany({ where: { userId: user.id } }),
          tx.employee.deleteMany({ where: { userId: user.id } }),
          tx.contractor.deleteMany({ where: { userId: user.id } }),
        ]);

        // STEP 3: Recreate tables based on main roles (using getMainBaseRole)
        const roleTableMap = {
          [ROLES_LIST.ADMIN]: () => tx.admin.create({ data: { userId: user.id } }),
          [ROLES_LIST.CUSTOMER]: () => tx.customer.create({ data: { userId: user.id } }),
          [ROLES_LIST.EMPLOYEE]: () => {
            // Use processed autoGenerated or existing data
            const finalAutoGenerated =
              processedAutoGenerated || user.employee?.autoGenerated;
            return tx.employee.create({
              data: { userId: user.id, autoGenerated: finalAutoGenerated },
            });
          },
          [ROLES_LIST.CONTRACTOR]: () => {
            const commissionValue = Number(
              commission ?? user.contractor?.commission ?? 0
            );

            if (isNaN(commissionValue)) {
              throw new Error("Commission must be a valid number");
            }
            if (commissionValue > 1) {
              throw new Error("Commission cannot be higher than 1 (100%)");
            }
            if (commissionValue < 0) {
              throw new Error("Commission cannot be negative");
            }

            return tx.contractor.create({
              data: { userId: user.id, commission: commissionValue },
            });
          },
        };

        // Determine main roles from roleIds using getMainBaseRole
        const roleNamesToCreateTables = await Promise.all(
          roles.map((roleId) => getMainBaseRole(prisma, roleId))
        );

        const uniqueRoleNames = [...new Set(roleNamesToCreateTables)].filter(
          Boolean
        );

        // Run mapped role table functions for main roles
        await Promise.all(
          uniqueRoleNames
            .filter((roleName) => roleTableMap[roleName])
            .map((roleName) => roleTableMap[roleName]())
        );
      }

      // STEP 4: Update branches if changed
      if (!needsApproval && branches && !arraysEqual(user.branches, branches)) {
        await tx.userBranch.deleteMany({ where: { userId: user.id } });
        await tx.userBranch.createMany({
          data: branches.map((branch) => ({
            userId: user.id,
            branchId: branch,
          })),
        });
      }

      const userDetails = await tx.user.findFirst({
        where: { id: editedUser.id },
        include: {
          roles: { include: { role: true } },
          branches: { include: { branch: true } },
          contractor: true,
          employee: true,
        },
      });

      return { userDetails, user };
    });

    let safeUser;
    if (!needsApproval) {
      const { hashPwd: _, refreshToken, ...rest } = result.userDetails;
      safeUser = rest;
    }

    await logActivity(
      req.username,
      needsApproval
        ? `FOR APPROVAL: ${req.username} edited User ${updatedData.username}`
        : `${req.username} edited User ${updatedData.username}`,
      remarks
    );

    // Update scheduler if employee autoGenerated changed
    if (
      !needsApproval &&
      roleBaseNames.includes(ROLES_LIST.EMPLOYEE) &&
      processedAutoGenerated
    ) {
      updateScheduler();
    }

    return res.status(201).json({
      message,
      data: needsApproval ? result.user : safeUser,
    });
  } catch (err) {
    console.log(err.message);
    return res.status(500).json({ error: err.message });
  }
};

// PUT me/
const editProfile = async (req, res) => {
  const { name, phone, email, description} = req.body;
  const newImage = req.file ? req.file.filename : null;

  try {
    let message;
    let existingUser;
    let pendingUser;

    const user = await prisma.user.findFirst({ where: { id: req.id } });

    if (email && email !== user.email) {
      existingUser = await prisma.user.findFirst({
        where: { email, id: { not: req.id }, status: "active", },
      });
      pendingUser = await checkPendingApproval(prisma, 'user', ['email'], email);
    }

    if (existingUser || pendingUser) {
      return res
        .status(400)
        .json({ message: "Email already in use or pending approval" });
    }

    let image = user.image;

    if (newImage) {
      if (user.image) {
        deleteFile(`images/${user.image}`);
      }
      image = newImage;
    }

    const updatedData = {
      fullName: name ?? user.fullName,
      username: user.username,
      phone: phone.toString() ?? user.phone,
      email: email ?? user.email,
      image: image ?? user.image,
      hashPwd: user.hashPwd,
      description: description ?? user.description,
      updatedByUser: req.username,
      image
    };

    const result = await prisma.$transaction(async (tx) => {
      const editedProfile = await tx.user.update({
        where: { id: user.id },
        data: updatedData,
      });

      message = "Profile edited successfully";

      return editedProfile;
    });

    await logActivity(
      req.username,
      `${req.username} edited User Profile ${updatedData.username}`,
    );

    return res.status(201).json({
      message,
      data: {
        ...(({ id, hashPwd, refreshToken, ...safeUser }) => safeUser)(result),
      },
    });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// PUT me/password
const editProfilePassword = async (req, res) => {
  const { oldPassword, newPassword } = req.body;

  const user = await prisma.user.findFirst({ where: { id: req.id } });

  const isMatch = await bcrypt.compare(oldPassword, user.hashPwd);
  if (!isMatch) {
    return res.status(400).json({ message: "Invalid old password" });
  }

  const strongPasswordRegex =
    /^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*])[A-Za-z\d!@#$%^&*]{8,}$/;

  if (!strongPasswordRegex.test(newPassword)) {
    return res.status(400).json({
      message:
        "Password must be at least 8 characters long, include an uppercase letter, a number, and a special character.",
    });
  }

  const hashPwd = await bcrypt.hash(newPassword, 10);

  const isUnchanged = await bcrypt.compare(oldPassword, hashPwd);
  if (isUnchanged) {
    return res
      .status(400)
      .json({ message: "New and old password cannot be the same" });
  }

  try {
    let message = "Profile password successfully changed";
    const updatedData = {
      fullName: user.fullName,
      username: user.username,
      phone: user.phone,
      email: user.email,
      hashPwd,
      description: user.description,
    };

    const result = await prisma.$transaction(async (tx) => {
      const editedProfilePassword = await tx.user.update({
        where: { id: user.id },
        data: updatedData,
      });
    });
    await logActivity(
      req.username,
      `${req.username} edited User ${updatedData.username}`,
    );

    return res.status(201).json({
      message,
    });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// PUT /users/:id/password
const editUserPassword = async (req, res) => {
  const { newPassword } = req.body;

  if (!req?.params?.id) {
    return res.status(400).json({ message: "ID is required" });
  }

  const user = await prisma.user.findFirst({ where: { id: req.params.id }, include: { branches: true } });
  if (!user) {
    return res
      .status(400)
      .json({ message: `User with ID ${req.params.id} doesn't exist` });
  }

  const strongPasswordRegex =
    /^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*])[A-Za-z\d!@#$%^&*]{8,}$/;

  if (!strongPasswordRegex.test(newPassword)) {
    return res.status(400).json({
      message:
        "Password must be at least 8 characters long, include an uppercase letter, a number, and a special character.",
    });
  }

  const hashPwd = await bcrypt.hash(newPassword, 10);

  try {
    const needsApproval = req.approval;
    let message;

    const updatedData = {
      fullName: user.fullName,
      username: user.username,
      phone: user.phone,
      email: user.email,
      hashPwd,
      description: user.description,
    };

    const result = await prisma.$transaction(async (tx) => {
      const editedUserPassword = needsApproval
        ? await requestApproval('user', req.params.id, 'edit', {
              ...updatedData,
              createdByUser: req.username }, req.username, user.branches?.[0]?.branchId)
        : await tx.user.update({
            where: { id: user.id },
            data: updatedData,
          });

      message = needsApproval
        ? "User password awaiting approval"
        : "User password successfully changed";
    });

    await logActivity(
      req.username,
      needsApproval
        ? `FOR APPROVAL: ${req.username} edited User Password ${updatedData.username}`
        : `${req.username} edited User Password ${updatedData.username}`, user.branches?.[0]?.branchId
    );

    return res.status(201).json({
      message,
    });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// DELETE /:id
const deleteUser = async (req, res) => {
  try {
    const needsApproval = req.approval;

    const user = await prisma.user.findUnique({
      where: { id: req.params.id },
      include: {
        branches: true,
        admin: true,
        customer: {
          include: {
            trucks: true,
            jobOrders: true,
          },
        },
        contractor: {
          include: {
            contractorPay: true,
            jobOrders: true,
          },
        },
        employee: {
          include: {
            employeePay: true
          },
        },

        // exclude these from relation checking
        roles: true,
        branches: true,

        // keep all other created/updated relations
        activityLog: true,
        createdUsers: true,
        updatedUsers: true,
        createdRole: true,
        createdBranches: true,
        createdTrucks: true,
        createdTransactions: true,
        createdJobOrders: true,
        createdContractorPays: true,
        createdEquipments: true,
        createdOtherIncomes: true,
        createdOverheads: true,
        transferredTruckOwnerships: true,
        updatedBranches: true,
        updatedTrucks: true,
        updatedTransactions: true,
        updatedJobOrders: true,
        updatedContractorPays: true,
        updatedEquipments: true,
        updatedOtherIncomes: true,
        updatedOverheads: true,
      },
    });

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // 🔍 Check relations, but ignore roles/branches/edits
    const excludedKeys = ["roles", "branches"];
    const hasRelations = relationsChecker(user, excludedKeys);
    console.log(hasRelations)

    let message = hasRelations ? "User marked as inactive (has related records)" : "User deleted successfully"

    await logActivity(
      req.username,
      needsApproval
        ? `FOR APPROVAL: ${req.username} deleted User ${user.username}`
        : `${req.username} deleted User ${user.username}`,
      user.branches?.[0]?.branchId
    );

    await prisma.$transaction(async (tx) => {

      if (needsApproval) {
        const approval = await requestApproval(
          "user", // table name
          user.id, // record id
          "delete", // action type
          user, // payload (snapshot of data)
          req.username, // requested by
          user.branches?.[0]?.branchId
        );

        return res.status(200).json({
          message: "User deletion pending approval",
          approvalId: approval.id, // include approval log ID here
        });
      }

      if (hasRelations) {
        await tx.user.update({
          where: { id: user.id },
          data: { status: "inactive", refreshToken: null, },
        });
      } else {
        // delete excluded relations first
        await tx.userRole.deleteMany({ where: { userId: user.id } });
        await tx.userBranch.deleteMany({ where: { userId: user.id } });

        await tx.customer.deleteMany({ where: { userId: user.id } });
        await tx.employee.deleteMany({ where: { userId: user.id } });
        await tx.contractor.deleteMany({ where: { userId: user.id } });
        await tx.admin.deleteMany({ where: { userId: user.id } });


        // finally delete the user
        await tx.user.delete({ where: { id: user.id } });
      }
    });

    return res.status(200).json({ message });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// GET /users
const getAllUsers = async (req, res) => {
  try {
    const role = req?.query?.role;
    const branch = req?.query?.branch;
    const search = req?.query?.search;
    const page = req?.query?.page && parseInt(req.query.page, 10);
    const limit = req?.query?.limit && parseInt(req.query.limit, 10);
    const startDate = req?.query?.startDate;
    const endDate = req?.query?.endDate;
    let totalItems = 0;
    let totalPages = 1;

    let where = { status: "active" };

    const createdAtFilter = getDateRangeFilter(startDate, endDate);
    if (createdAtFilter) {
      where.createdAt = createdAtFilter;
    }

    where = {...where, ...branchFilter("user", branch, req.branchIds)};

    //  Filter by role
    if (role) {
      where.roles = {
        some: {
          roleId: role, // since UserRole has roleId
        },
      };
    }

    if (branch) {
      let branchValue = req.query.branch.trim().replace(/^["']|["']$/g, "");
      where.branches = {
        some: {
          branch: {
            branchId: branchValue,
          },
        },
      };
    }

    //  Search filter
    if (search) {
      let searchValue = req.query.search.trim().replace(/^["']|["']$/g, "");

      where.OR = [
        { fullName: { contains: searchValue } },
        { username: { contains: searchValue } },
      ];
    }

    const lastUpdatedAt = await getLastUpdatedAt(prisma, "user", where);
    //  Query and pagination
    const result = await prisma.$transaction(async (tx) => {
      const users = await tx.user.findMany({
        where,
        ...(page && limit ? { skip: (page - 1) * limit } : {}),
        ...(limit ? { take: limit } : {}),
        orderBy: {
          createdAt: "desc",
        },
        include: {
          roles: { include: { role: true } },
          branches: { include: { branch: true } },
          admin: { select: { id: true } },
          customer: { select: { id: true } },
          contractor: { select: { commission: true, id: true } },
          employee: { select: { autoGenerated: true, id: true } },
        },
      });

      totalItems = await tx.user.count({ where });
      if (limit) totalPages = Math.ceil(totalItems / limit);

      // Exclude sensitive fields
      const formattedUsers = users.map((user) => {
        const { hashPwd, refreshToken, roles, branches, contractor, employee, customer, admin, ...safeUser } = user;

        return {
          ...safeUser,
          roles: roles.map((r) => ({
            id: r.role.id,
            roleName: r.role.roleName,
          })),
          branches: branches.map((b) => ({
            id: b.branch.id,
            branchName: b.branch.branchName,
          })),
          contractor: contractor
            ? {
                id: contractor.id,
                commission: Number(contractor.commission),
              }
            : null,
          employee: employee
            ? {
                id: employee.id,
                autoGenerated: employee.autoGenerated,
              }
            : null,
            admin: admin ? { id: admin.id } : null,
            customer: customer ? { id: customer.id } : null,
          commission: Number(contractor?.commission) || undefined,
          autoGenerated: employee?.autoGenerated || undefined,
        };
      });

      return { users: formattedUsers };
    });
    


    res.status(200).json({
      data: {
        ...result,
        pagination: { totalItems, totalPages },
        lastUpdatedAt,
      },
    });
  } catch (err) {
    console.error(err.message);
    res.status(500).json({ error: err.message });
  }
};

// GET /:id
const getUser = async (req, res) => {
  if (!req?.params?.id)
    return res.status(400).json({ message: "ID is required" });

  try {
    const user = await prisma.user.findUnique({
      where: { id: req.params.id },
      include: {
        roles: { include: { role: true } },
        branches: { include: { branch: true } },
        contractor: true, 
        employee: { select: { autoGenerated: true }}// Direct relation without nested include
      },
    });

    if (!user) return res.status(404).json({ message: "User not found" });

    const { hashPwd, refreshToken, roles, branches, contractor, ...safeUser } =
      user;

    // Prepare response data
    const responseData = {
      ...safeUser,
      roles: roles.map((r) => ({
        id: r.role.id,
        roleName: r.role.roleName,
      })),
      branches: branches.map((b) => ({
        id: b.branch.id,
        branchName: b.branch.branchName,
      })),
      employeeAutoGenerated: user.employee ? user.employee.autoGenerated : null,
    };

    // Add commission if contractor relation exists
    if (contractor) {
      responseData.commission = contractor.commission || null;
      // Add other contractor fields as needed
      // responseData.autoGenerated = contractor.autoGenerated || null;
    }

    return res.status(200).json({
      data: responseData,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// GET /me
const getMyProfile = async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.id },
      include: {
        roles: { select: { role: { select: { id: true, roleName: true } } } },
        branches: { select: { branch: { select: { id: true, branchName: true } } } },
      },
    });

    if (!user) return res.status(404).json({ message: "User not found" });

    const transformedUser = {
      ...user,
      roles: user.roles.map(r => r.role),
      branches: user.branches.map(b => b.branch),
    };

    const { hashPwd, refreshToken, ...safeUser } = transformedUser;

    res.status(200).json({
      data: {
        ...safeUser,
        // roles: roles.map((r) => r.role.roleName),
        // branches: branches.map((b) => b.branch.branchName),
      },
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

module.exports = {
  createUser,
  editUser,
  editProfile,
  editProfilePassword,
  getAllUsers,
  editUserPassword,
  deleteUser,
  getUser,
  getMyProfile
};
